<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>每日一题10.1-10.9 - Red</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=每日一题>
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="Red" type="application/atom+xml">
  

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">Red</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
    </ul>
  </nav>
</header>
<article class="post">
  <div class="post-title">
    <h1 class="article-title">每日一题10.1-10.9</h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2021-10-09</span>
  </div>
  <div class="post-content">
    <blockquote>
<p>最近都在写最小生成树和前缀和差分及一些杂题，趁着周末做个小总结，牛客打卡打到第17天结果那天恰好忘记打卡了（悲）题目顺序和时间无关。。</p>
</blockquote>
<span id="more"></span>

<h2 id="P1115-最大子段和"><a href="#P1115-最大子段和" class="headerlink" title="P1115 最大子段和"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1115">P1115 最大子段和</a></h2><p>比较经典的dp问题，但是俺是个dp小白，本来学了前缀和与差分之后去写这个题单结果上来就是这个题，如果使用前缀和的话我只会用暴力来做，所以还是来写个dp吧。</p>
<p>dp 其实也比较好想，每次连续的一段子序列的和必定是由前面的和加上这个子序列的最后一个数，我们让前面的那一段子序列的和叫 dp[i - 1]，该子序列最后一个数叫 a[i]，那么如果加上 a[i] 使得整个的和大于 a[i] 的话，那么dp[i]肯定就是dp[i - 1] + a[i] 了，反之，如果加了之后比 a[i] 还小，那还不如只要 a[i]，所以让dp[i] &#x3D; a[i] ，这样就相当于重新开始一个新的子序列了，每次取 dp[i] 的最大即可。</p>
<p><strong>AC code</strong></p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, a[N], dp[N], ans = <span class="number">-1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i - <span class="number">1</span>] + a[i] &gt; a[i])</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        <span class="keyword">else</span> dp[i] = a[i];</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P4047-JSOI2010-部落划分"><a href="#P4047-JSOI2010-部落划分" class="headerlink" title="P4047 [JSOI2010]部落划分"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4047">P4047 [JSOI2010]部落划分</a></h2><p>其实这个题它虽然是个绿题，但是其实非常好想，只要建一棵最小生成树（为什么不是最大生成树呢？因为要求<strong>同一个部落的野人总是生活在附近</strong>），然后取最后的 k 个点为部落中的代表点，即最后的 k - 1 条边，取其中的第一条边即可。即最后第 n - 1 - (k - 1) + 1 &#x3D; n - k + 1条边。</p>
<p><strong>AC code</strong></p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">double</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;node&gt; ifo, gh;</span><br><span class="line"><span class="type">int</span> n, k, f[N], bian = <span class="number">0</span>, fg = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> ans = <span class="number">5e8</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == f[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    f[<span class="built_in">find</span>(y)] = <span class="built_in">find</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">krus</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)gh.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="comment">// if(bian == n - k) fg = 1;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(gh[i].x) != <span class="built_in">find</span>(gh[i].y))&#123;</span><br><span class="line">            <span class="built_in">merge</span>(gh[i].x, gh[i].y);</span><br><span class="line">            bian ++;        </span><br><span class="line">            <span class="keyword">if</span>(bian == n - k + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>, gh[i].val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    ifo.<span class="built_in">push_back</span>(&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        f[i] = i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        ifo.<span class="built_in">push_back</span>(&#123;a, b, <span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="type">double</span> v = <span class="built_in">sqrt</span>((ifo[i].x - ifo[j].x) * (ifo[i].x - ifo[j].x) + (ifo[i].y - ifo[j].y) * (ifo[i].y - ifo[j].y));</span><br><span class="line">            gh.<span class="built_in">push_back</span>(&#123;i, j, v&#125;);</span><br><span class="line">            gh.<span class="built_in">push_back</span>(&#123;j, i, v&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(gh.<span class="built_in">begin</span>(), gh.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="built_in">krus</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NC156-数组中只出现一次的数（其它数出现k次）"><a href="#NC156-数组中只出现一次的数（其它数出现k次）" class="headerlink" title="NC156 数组中只出现一次的数（其它数出现k次）"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/5d3d74c3bf7f4e368e03096bb8857871?tpId=188&&tqId=38592&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">NC156 数组中只出现一次的数（其它数出现k次）</a></h2><p>这个题算是一个小技巧吧，也记录下。排序后，只要遇到和后一个数相等的数就相当于这个数是 k 次出现的数的第一个数，直接 i +&#x3D; k - 1（减 1是因为循环中 i 还得加 1）。</p>
<p><strong>AC code</strong></p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param arr intvector </span></span><br><span class="line"><span class="comment">     * @param k int </span></span><br><span class="line"><span class="comment">     * @return int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foundOnceNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == arr[i + <span class="number">1</span>])&#123;</span><br><span class="line">                i += k - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[arr.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="NC41-最长无重复子数组"><a href="#NC41-最长无重复子数组" class="headerlink" title="NC41 最长无重复子数组"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=188&&tqId=38553&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">NC41 最长无重复子数组</a></h2><p>这个题算是一个 stl 的使用小技巧。</p>
<p><strong>在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序。应该注意的是set中数元素的值不能直接被改变。</strong></p>
<p>count() 用来查找set中某个某个键值出现的次数。但是答案只有 0 或者 1。所以这样其实就变成了<strong>判断某一键值是否在 set 中出现过了</strong>。</p>
<p>应用到这个题，i 和 j 相当于双指针，分别指向某子数组的头和尾，插入某元素arr[j++]之后，一旦发现它的下一个数 arr[j] 出现过，就说明开始出现重复的元素了。此时只要这个重复元素一直在 set 中，我们就将前面的 j - i 个数 erase 掉，然后继续重复这个操作。</p>
<p><strong>AC code</strong></p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param arr int整型vector the array</span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        set&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> mlen = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; arr.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(ans.<span class="built_in">count</span>(arr[j]))&#123;</span><br><span class="line">                ans.<span class="built_in">erase</span>(arr[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">insert</span>(arr[j++]);</span><br><span class="line">            mlen = <span class="built_in">max</span>(mlen, j - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="102-最佳牛围栏"><a href="#102-最佳牛围栏" class="headerlink" title="102. 最佳牛围栏"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/104/">102. 最佳牛围栏</a></h2><p>神奇的二分题，check 函数大致的想法其实和答案比较接近，但是开始的时候处理的相当的烂，最初是想找一个最大子段和，但是显然，我并没有考虑到还得去平均，所以直接去找最大子段和的想法必然是行不通的。</p>
<p>那么如何去找最大的平均数呢？其实反过来想就好了。check函数中传进去的值 x 我们已经假定了它就是答案，那么：</p>
<ul>
<li><p>此题的二分性质为，小于答案的一定存在，而大于答案的一定不可能找到。</p>
</li>
<li><p>若s[]为cow[]的前缀和，j - i &gt;&#x3D; f，则有：</p>
<p><img src="/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%9110-1-10-9/image-20211009113411017.png" alt="image-20211009113411017"></p>
</li>
<li><p>这样就非常明显了，只要定义 i 和 j ，让它们的起点分别为 0 和 f ，让s[i] - (i + 1)*x尽可能小，而只要s[j] - (j + 1)*x大于 x，x就是一个可行的答案。</p>
</li>
</ul>
<p><strong>AC code</strong></p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, f, cow[N];</span><br><span class="line"><span class="type">double</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + cow[i] - x; <span class="comment">//求前缀和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = f; j &lt;= n; j++, i++)&#123; <span class="comment">//双指针求满足某个区间平均值大于等于x</span></span><br><span class="line">        ans = <span class="built_in">min</span>(ans, s[i]);</span><br><span class="line">        <span class="keyword">if</span>(s[j] &gt;= ans) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; f;</span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cow[i]);</span><br><span class="line">        r = <span class="built_in">max</span>(r, (<span class="type">double</span>)cow[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; <span class="number">1e-5</span>)&#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="type">int</span>)(r * <span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P2671-NOIP2015-普及组-求和"><a href="#P2671-NOIP2015-普及组-求和" class="headerlink" title="P2671 [NOIP2015 普及组] 求和"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2671">P2671 [NOIP2015 普及组] 求和</a></h2><p>前缀和差分题单中总有各种神奇的题目，比如说这个题，实际上它是一道数学题。</p>
<p>实际上要找的是颜色相同的偶数对和奇数对，那么我们提前先做好处理，求出不同颜色下为偶数的个数和为奇数的个数，用一个二维数组s[][]来储存。然后是公式推导：</p>
<p><img src="/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%9110-1-10-9/image-20211009173839277.png" alt="image-20211009173839277"></p>
<p><strong>AC code</strong></p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, mod = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, num[N], col[N], ans = <span class="number">0</span>, sumcol[N][<span class="number">2</span>], s[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;col[i]);</span><br><span class="line">        s[col[i]][i % <span class="number">2</span>]++;</span><br><span class="line">        sumcol[col[i]][i % <span class="number">2</span>] += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> a = (sumcol[col[i]][i % <span class="number">2</span>] % mod + (s[col[i]][i % <span class="number">2</span>] - <span class="number">2</span>) * i % mod) % mod;</span><br><span class="line">        ans = (ans + ((num[i] % mod) * a) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3995-最小的和（贪心）"><a href="#3995-最小的和（贪心）" class="headerlink" title="3995. 最小的和（贪心）"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3998/">3995. 最小的和（贪心）</a></h2><p>所谓的掉分之夜（悲）都说这场简单怎么我就打自闭了呢。</p>
<p>贪心，每次取最大的减 1 保证整体最小，而不应该是一下取最大变得尽可能小。。。</p>
<p>我脑回路和正常人可能不一样吧。自闭了。</p>
<p>y 总能给出详尽的证明也太强了吧%%%%%%%%%%%</p>
<p>AC code</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, k1, k2, a[N], b[N];</span><br><span class="line">priority_queue&lt;<span class="type">long</span> <span class="type">long</span>&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k1 &gt;&gt; k2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;b[i]);</span><br><span class="line">        c.<span class="built_in">push</span>(<span class="built_in">abs</span>(a[i] - b[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k1 + k2; i++)&#123;</span><br><span class="line">        <span class="type">int</span> val = c.<span class="built_in">top</span>();</span><br><span class="line">        c.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(val == <span class="number">0</span>)&#123;</span><br><span class="line">            k = k1 + k2 - i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        val --;</span><br><span class="line">        c.<span class="built_in">push</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> val = c.<span class="built_in">top</span>();</span><br><span class="line">        c.<span class="built_in">pop</span>();</span><br><span class="line">        ans += (<span class="type">long</span> <span class="type">long</span>)val * val; </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans + k % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3996-涂色（区间DP）"><a href="#3996-涂色（区间DP）" class="headerlink" title="3996. 涂色（区间DP）"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3999/">3996. 涂色（区间DP）</a></h2><p>又是一道 dp，对我这种 dp 小白来说太不友好了（</p>
<p>晚上看了 y 总的讲解，只能说 y 总 yyds，证明过程实在是太详细了。写上一点自己的理解：</p>
<p>首先需要<strong>缩点</strong>，只要是一个连通块中的点只需要一个即可，不会影响答案，而且方便后续操作。</p>
<p>然后分情况讨论，在区间 [l, r] ：</p>
<ul>
<li>若左右端点的颜色<strong>不相同</strong>：从右边扩最后扩到左边是dp[l][r] &#x3D; dp[l + 1][r] + 1，从左开始扩与此反对称：dp[l][r] &#x3D; dp[l][r - 1] + 1</li>
<li>若左右端点的颜色<strong>相同</strong>：<ul>
<li>从中间开始扩展，最后<strong>只需要一步将整体的颜色变成和两边一样的颜色</strong>，所以需要加 1，即dp[l][r] &#x3D; dp[l + 1][r - 1] + 1</li>
<li>从左边或者右边开始扩展，由于两边是对称的，所以只考虑一边的情况，如果从左边开始扩展：<ul>
<li>首先从 l 扩到 l + 1，需要 1 步</li>
<li>然后从 l + 1 扩到 r - 1，至少需要 dp[l + 1][r - 1] - 1 步，为什么要减 1 呢？因为第一步先将 l + 1 变色了，很可能会导致原dp[l + 1][r - 1]的步数减少一步，所以需要减去 1</li>
<li>最后从 r - 1 扩到 r，需要 1 步</li>
<li>所以整体至少需要dp[l + 1][r - 1] + 1步</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>AC code</strong></p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>;</span><br><span class="line"><span class="type">int</span> n, c[N], dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">        <span class="keyword">if</span>(c[i] == c[i - <span class="number">1</span>] &amp;&amp; i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            i --;</span><br><span class="line">            n --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>; l + len - <span class="number">1</span> &lt; n; l++)&#123;</span><br><span class="line">            <span class="type">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(c[l] != c[r]) dp[l][r] = <span class="built_in">min</span>(dp[l + <span class="number">1</span>][r] + <span class="number">1</span>, dp[l][r - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> dp[l][r] = dp[l + <span class="number">1</span>][r - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


  </div>
  <div class="post-footer">
    
      <ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" rel="tag">每日一题</a></li></ul>
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>
<footer>
  &copy; 2022
  <span class="author">
    red
  </span>
</footer>
    </div>
  </body>
</html>