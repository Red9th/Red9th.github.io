<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>扩展欧几里得算法 - Red</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=算法学习笔记,数论>
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="Red" type="application/atom+xml">
  

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">Red</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
    </ul>
  </nav>
</header>
<article class="post">
  <div class="post-title">
    <h1 class="article-title">扩展欧几里得算法</h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2021-12-08</span>
  </div>
  <div class="post-content">
    <p>扩展欧几里得定理。</p>
<span id="more"></span>

<h1 id="扩展欧几里得定理"><a href="#扩展欧几里得定理" class="headerlink" title="扩展欧几里得定理"></a>扩展欧几里得定理</h1><blockquote>
<p><strong>裴署定理</strong>：对于任意正整数 a，b，一定存在非零整数 x，y，使得 ax + by &#x3D; (a, b)。</p>
<p>扩展欧几里得算法就是在辗转相除的过程中求出裴署定理的整数解。</p>
</blockquote>
<p><strong>求解过程：</strong>由于扩展欧几里得算法是在利用欧几里得算法求解 a 和 b 的最大公约数的过程中求出 x 和 y 的，所以相当于是一个迭代的过程，这里给出由 $gcd(a,b)$ 到 $gcd(b, a\mod b)$ 迭代过程中的第一次迭代的解。</p>
<p>设 $x &#x3D; x_1,y&#x3D;y_1$ 是 $ax + by&#x3D;(a, b)$ 的解， 即 $ax_1 + by_1&#x3D;(a, b)$。</p>
<p>设 $x &#x3D; x_2,y&#x3D;y_2$ 是 $bx + (a \mod b) y&#x3D;(b, a \mod b)$ 的解， 即 。$bx_2 + (a \mod b) y_2&#x3D;(b, a \mod b)$。</p>
<p>根据欧几里得定理：$gcd(a,b)&#x3D;gcd(b, a\mod b)$。</p>
<p>所以有 $ax_1 + by_1&#x3D;bx_2 + (a \mod b) y_2$，又因为 $a \mod b&#x3D;[a - \frac{a}{b}]b$。假设 $x_1,y_1$ 已知。</p>
<p>所以解得：$x_1&#x3D;y_2,y_1&#x3D;x_2-[\frac{a}{b}]y_2$。</p>
<p>当迭代到最后 b &#x3D; 0 时，显然最大公约数为最后一次迭代的 a，此时得到方程的解为：$x_n&#x3D;1,b_n&#x3D;0$，根据这组解就可以反过来推出 $x_{n-1},y_{n-1}$ 的解，最后就可以推出 $x_1,y_1$ 的解。</p>
<h2 id="877-扩展欧几里得算法"><a href="#877-扩展欧几里得算法" class="headerlink" title="877. 扩展欧几里得算法"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/879/">877. 扩展欧几里得算法</a></h2><p>代码实现上，使用递归率先得到最后一层的方程的解（即 $x&#x3D;1,y&#x3D;0$），然后再一层一层退回来，得到每一层的解，从而得到最上层的 $x_1,y_1$ 的解。注意 x 和 y 都需要使用引用或者指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="type">int</span> t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t - a / b * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一种写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h1><p>形如  $ax≡b \pmod n$ 的方程称为线性同余方程。此方程有解当且仅当 b 能被 a 与 n 的最大公约数整除（ $gcd(a,n) | b$）。</p>
<p><strong>求解过程：</strong></p>
<p>由线性同余方程可得，存在整数 y 使得 $ax&#x3D;ny+b$。</p>
<p>整理得：$ax+n(-y)&#x3D;b$，当 $gcd(a,n) | b$ 时，该方程满足裴署定理，可以使用扩展欧几里得定理求得 x 的解。</p>
<h2 id="878-线性同余方程"><a href="#878-线性同余方程" class="headerlink" title="878. 线性同余方程"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/880/">878. 线性同余方程</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> n </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="type">int</span> t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> a, b, m;</span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;m);</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">exgcd</span>(a, m, x, y);</span><br><span class="line">        <span class="keyword">if</span>(b % d) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (LL)x * (b / d) % m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是最后为什么需要再模上 m：首先是为了防止爆 int，然后由于所求实际为 $ax \mod n &#x3D;b$ 中 x 的值，在上述过程中已经求出了方程的一个特解设为 $x_0$，那么通解为 $x_0+k\frac{n}{(a,n)},k∈Z$。当 k 取 $(a,n)$ 的整数倍且取负时，显然 $x_0 \mod n$ 也是原方程的一个解，因此最后模 m 既防止了溢出，又能保证结果是原方程的解。</p>
<h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><p>一元线性同余方程组：$$ \left{ \begin{aligned} x &amp; ≡  a_1 \pmod {m_1}  \ x &amp;≡ a_2 \pmod {m_2} \&amp;…\ x &amp;≡ a_k \pmod {m_k} \end{aligned} \right. $$</p>
<p>其中，$m_1,m_2,…,m_k$ 两两互质。</p>
<p>令$M&#x3D;m_1m_2…m_k$，$M_i&#x3D;\frac{M}{m_i}$。$M_i^{-1}$ 表示 $M_i$ 模 $m_i$ 的逆元。</p>
<p>该方程组的解为：$x&#x3D;a_1M_1{M_1}^{-1}+a_2M_2{M_2}^{-1}+…+a_kM_k{M_k}^{-1}$</p>
<p>这里 $m_i$ 不一定为质数，所以不能用费马小定理来求解，可以直接使用扩展欧几里得算法解线性同余方程 $1 ≡ M_iM_i^{-1} \pmod {m_i}$ 求 $M_i$ 模 $m_i$ 的逆元。</p>
<p>证明：因为 $M_iM_1^{-1} \mod m_1&#x3D;1$，而后面的 $M_i$ 均含 $m_1$ ，所以后面的项全部为 0，因此解满足第一个方程，同理可以推出此解满足后面的方程。</p>
<h1 id="扩展中国剩余定理"><a href="#扩展中国剩余定理" class="headerlink" title="扩展中国剩余定理"></a>扩展中国剩余定理</h1><p>去掉了中国剩余定理中“$m_1,m_2,…,m_k$ 两两互质。”这条限制。</p>
<p><strong>求解过程：</strong></p>
<p>对方程 $x ≡ m_1 \pmod {a_1},x ≡ m_2 \pmod {a_2}$ 来说，有下式：</p>
<p>$x&#x3D;k_1a_1+m_1,x&#x3D;k_2a_2+m_2$，则 $k_1a_1+m_1&#x3D;k_2a_2+m_2$。即 $k_1a_1-k_2a_2&#x3D;m_2-m_1$。</p>
<p>该方程有解等价于 $(a_1,a_2)|(m_2-m_1)$。</p>
<p>根据之前的线性同余方程的知识，可以知道 $k_1$ 的通解为 $k_1+k\frac{a_2}{(a_1,a_2)},k∈Z$。</p>
<p>带入方程 $x&#x3D;k_1a_1+m_1$ 中有：$x&#x3D;k_1a_1+m_1+k\frac{a_1a_2}{(a_1,a_2)}&#x3D;k_1a_1+m_1+k[a_1,a_2]$。（$[a_1,a_2]$ 指 $a_1,a_2$ 的最小公倍数）</p>
<p>令 $m&#x3D;k_1a_1+m_1,a&#x3D;[a_1,a_2],x&#x3D;ka+m$，那么 $m$ 和 $a$ 已知，相当于把之前两个同类型的式子化简成了一个同类型的式子，那么线性同余方程组只要这样化简 $n-1$ 次就可以变成一个这样的式子。</p>
<h2 id="204-表达整数的奇怪方式"><a href="#204-表达整数的奇怪方式" class="headerlink" title="204. 表达整数的奇怪方式"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/206/">204. 表达整数的奇怪方式</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30</span>;</span><br><span class="line">LL n, m[N], a[N], res, M = <span class="number">1</span>, flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL d = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    LL t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL a1, a2, m1, m2;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; a1 &gt;&gt; m1;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a2 &gt;&gt; m2;</span><br><span class="line">        LL k1, k2;</span><br><span class="line">        LL d = <span class="built_in">exgcd</span>(a1, a2, k1, k2);</span><br><span class="line">        <span class="keyword">if</span>((m2 - m1) % d)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k1 *= (m2 - m1) / d;</span><br><span class="line">        LL t = a2 / d;</span><br><span class="line">        k1 = (k1 % t + t) % t; <span class="comment">// k要求得小的解，避免爆掉</span></span><br><span class="line">        </span><br><span class="line">        m1 = k1 * a1 + m1;</span><br><span class="line">        a1 = <span class="built_in">abs</span>(a1 / d * a2); <span class="comment">// 此处如果写成a1 * a2 / d很容易因为先乘的两个数爆掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; (m1 % a1 + a1) % a1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


  </div>
  <div class="post-footer">
    
      <ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%95%B0%E8%AE%BA/" rel="tag">数论</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">算法学习笔记</a></li></ul>
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>
<footer>
  &copy; 2022
  <span class="author">
    red
  </span>
</footer>
    </div>
  </body>
</html>