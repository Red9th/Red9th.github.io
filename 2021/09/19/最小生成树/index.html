<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>最小生成树 - Red</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=算法学习笔记>
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="Red" type="application/atom+xml">
  

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">Red</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
    </ul>
  </nav>
</header>
<article class="post">
  <div class="post-title">
    <h1 class="article-title">最小生成树</h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2021-09-19</span>
  </div>
  <div class="post-content">
    <blockquote>
<p>本文主要说明最小生成树 Kruskal 算法和 Prim 算法的原理，Prim 算法（优先队列优化）和 Kruskal 算法如何用线形基实现。</p>
</blockquote>
<span id="more"></span>

<p>首先介绍一些概念：（摘自百度，以及个人理解）</p>
<ul>
<li><strong>连通图</strong>：在一个无向图G 中，若从顶点 i 到顶点 j 有路径相连（当然从 j 到 i 也一定有路径），则称 i 和 j 是连通的。如果图中任意两点都是连通的，那么图被称作连通图。</li>
<li><strong>连通网</strong>：每条边都有边权的连通图。</li>
<li><strong>强连通图</strong>：有向图 (<em>G</em>&#x3D;(<em>V</em>,<em>E</em>) 中，若对于V中任意两个不同的顶点 <em>x</em> 和 <em>y</em>，都存在从 <em>x</em> 到  <em>y</em> 以及从 <em>y</em> 到 <em>x</em> 的路径，则称 <em>G</em> 是强连通图。</li>
<li><strong>生成树</strong>：用 n-1 条边将图上的 n 个点连接起来，形成的树就称为生成树。</li>
<li><strong>最小生成树</strong>：在连通图的所有生成树中，所有边权之和最小的生成树称为最小生成树。</li>
</ul>
<p><img src="/%E3%80%90%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20211103114119180.png" alt="image-20211103114119180"></p>
<h2 id="1-Kruskal算法"><a href="#1-Kruskal算法" class="headerlink" title="1. Kruskal算法"></a>1. Kruskal算法</h2><p>本文的 Kruskal 算法主要使用线形基实现。初始时，每个顶点都是一棵树，并且对并查集进行初始化。</p>
<ol>
<li>存图，对所有的边权从小到大排序。</li>
<li>依次遍历边权。对于每次遍历，判断这条边上的两点是否在一棵树上，如果不在一棵树上，就将其中一点加入另外一点的树上；并查集操作就是将该点 merge 到这一点的集合中。</li>
<li>若最后所有的点的父亲 fa[i] 相同，说明所有点都在一棵树上，因此生成了最小生成树，否则无法生成，该图不连通。</li>
</ol>
<p><img src="/%E3%80%90%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20210915110659395.png" alt="image-20210915110659395"></p>
<h2 id="2-Prim算法"><a href="#2-Prim算法" class="headerlink" title="2. Prim算法"></a>2. Prim算法</h2><p>Prim 算法与Kruskal 算法的不同点在于一个是K是在加边，而P是在加点。Prim 算法比较适合稠密图。</p>
<ol>
<li>存图，可以用 vector 套 vector 存，每个点直接相邻的点及其距离都可以知道。或者链式前向星也可以。</li>
<li>每个点的 vis 状态设为 0，表示开始时没有点在生成树上。</li>
<li>定义一个优先队列 q，这个优先队列存一条边的边权和 to 值。form 值可以不用存。</li>
<li>只要 q 不为空，每次就先取出队首，判断其是否访问过，然后对其相连的点进行扩展（和 dij 比较像），没有访问过的点就 push 进 q 中，因为优先队列会根据规则给队列中的数据排序，如果用 greater，就说明 q 中的数据是从小到大排的，这样可以直接通过取出队首这个操作，得到每次加点时的最小边了。</li>
</ol>
<p><img src="/%E3%80%90%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/image-20210920105618256.png" alt="image-20210920105618256"></p>
<h2 id="3-例题"><a href="#3-例题" class="headerlink" title="3. 例题"></a>3. 例题</h2><h3 id="P3366-【模板】最小生成树"><a href="#P3366-【模板】最小生成树" class="headerlink" title="P3366 【模板】最小生成树"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树</a></h3><p>很简单，就纯纯的使用最小生成树，当然里面还有部分并查集的操作。</p>
<p><strong>AC code</strong></p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> u, v, cost;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)&#123;</span><br><span class="line">        u = x, v = y;</span><br><span class="line">        cost = z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, fa[N], sum = <span class="number">0</span>;</span><br><span class="line">vector&lt;node&gt; gh, tr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        tr[i].<span class="built_in">push_back</span>(<span class="built_in">node</span>(i, i, <span class="number">0</span>));</span><br><span class="line">        fa[i] = i; <span class="comment">//并查集初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(gh[i].u) != <span class="built_in">find</span>(gh[i].v))&#123;</span><br><span class="line">            tr[gh[i].u].<span class="built_in">push_back</span>(<span class="built_in">node</span>(gh[i].u, gh[i].v, gh[i].cost));</span><br><span class="line">            <span class="built_in">merge</span>(gh[i].u, gh[i].v);</span><br><span class="line">            sum += gh[i].cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">com</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost &lt; b.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        gh.<span class="built_in">push_back</span>(<span class="built_in">node</span>(x, y, z));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(gh.<span class="built_in">begin</span>(), gh.<span class="built_in">end</span>(), com);</span><br><span class="line">    <span class="built_in">kruskal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> laoda = <span class="built_in">find</span>(<span class="number">1</span>), f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i) != laoda)&#123;</span><br><span class="line">            f = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;orz&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="P2872-USACO07DEC-Building-Roads-S"><a href="#P2872-USACO07DEC-Building-Roads-S" class="headerlink" title="P2872 [USACO07DEC]Building Roads S"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2872">P2872 [USACO07DEC]Building Roads S</a></h3><p>比板子复杂了一丢丢的黄题，思路是在原有部分连通的基础上，以最小的代价让整张图连通，那这就肯定用到最小生成树了嘛。最小生成树的关键步骤，就是边权从小到大遍历，每次遍历时都要看所连接的两个点是否在一棵树上，只要不在，就将两个点合并。</p>
<p>想到这里，到这个题就很好做了，只要在原有图的基础上，将连通的点加入对应的树上，然后再将所有点中，两两点求距离（cost），再排序，最后从小到大遍历一遍，只要发现有两个点不在同一棵树上的，就将两点合并，而这条边就是我们需要添加进去的边，依次类推。</p>
<p>感觉坑点主要是这个精度啊，交了一发 float 只过了50%，交 double 就 ac 了，很神奇。</p>
<p><strong>AC code</strong></p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="type">double</span> cost;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">double</span> z)&#123;</span><br><span class="line">        u = x, v = y;</span><br><span class="line">        cost = z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edge;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">double</span> i, <span class="type">double</span> j)&#123;</span><br><span class="line">        x = i;</span><br><span class="line">        y = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; node;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, fa[N]; </span><br><span class="line"><span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">vector&lt;edge&gt; gh, tr[N], no;</span><br><span class="line">vector&lt;node&gt; li; <span class="comment">//点的坐标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(y)] = <span class="built_in">find</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">com</span><span class="params">(edge a, edge b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost &lt; b.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    li.<span class="built_in">push_back</span>(<span class="built_in">node</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        li.<span class="built_in">push_back</span>(<span class="built_in">node</span>(a, b));</span><br><span class="line">        tr[i].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(i, i, <span class="number">0</span>));</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">merge</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="type">double</span> cos = <span class="built_in">sqrt</span>((li[i].x - li[j].x) * (li[i].x - li[j].x) + (li[i].y - li[j].y) * (li[i].y - li[j].y));</span><br><span class="line">            no.<span class="built_in">push_back</span>(<span class="built_in">edge</span>(i, j, cos));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(no.<span class="built_in">begin</span>(), no.<span class="built_in">end</span>(), com);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)no.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(no[i].u) != <span class="built_in">find</span>(no[i].v))&#123;</span><br><span class="line">            <span class="built_in">merge</span>(no[i].u, no[i].v);</span><br><span class="line">            tr[no[i].u].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(no[i].u, no[i].v, no[i].cost));</span><br><span class="line">            ans += no[i].cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="P1991-无线通讯网"><a href="#P1991-无线通讯网" class="headerlink" title="P1991 无线通讯网"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1991">P1991 无线通讯网</a></h3><p>这个题其实在于最后的卫星电话上面，这个地方卡了很久orz…</p>
<p>首先可以知道一些条件：</p>
<ul>
<li>每个哨所都装有无线电收发器，也就是说在不考虑卫星电话的情况下，只要D大于任意两点之间距离的最大值，任意两点之间都可以通信。</li>
<li>只有当两个哨所同时配备有卫星电话，两个哨所之间才能畅通无阻。</li>
</ul>
<p>我们会根据这些点生成一棵最小生成树，这棵树的一共有 P 个点，P - 1 条边。如果有 S 个卫星电话，由于该图是一个无向完全图，所以一定可以连通 S - 1 条边。所以最后的答案就是最小生成树中前 P - S 条边的最大值。</p>
<p><strong>AC code</strong></p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> i, <span class="type">int</span> j)&#123;</span><br><span class="line">        x = i;</span><br><span class="line">        y = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u, v, ub, vb;</span><br><span class="line">    <span class="type">double</span> cost;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">double</span> t)&#123;</span><br><span class="line">        u = i;</span><br><span class="line">        v = j;</span><br><span class="line">        cost = t;</span><br><span class="line">        ub = <span class="number">0</span>, vb = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> s, p, fa[N],ans = <span class="number">0</span>;</span><br><span class="line">vector&lt; Node&gt; li;</span><br><span class="line">vector&lt;edge&gt; tr[N], no;</span><br><span class="line">vector&lt;edge&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(y)] = <span class="built_in">find</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">com</span><span class="params">(edge a, edge b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost &lt; b.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; p;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    li.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        li.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(a, b));</span><br><span class="line">        tr[i].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(i, i, <span class="number">0</span>));</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= p; j++)&#123;</span><br><span class="line">            <span class="type">double</span> cos = <span class="built_in">sqrt</span>((li[i].x - li[j].x) * (li[i].x - li[j].x) + (li[i].y - li[j].y) * (li[i].y - li[j].y));</span><br><span class="line">            no.<span class="built_in">push_back</span>(<span class="built_in">edge</span>(i, j, cos));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(no.<span class="built_in">begin</span>(), no.<span class="built_in">end</span>(), com);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)no.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(no[i].u) != <span class="built_in">find</span>(no[i].v))&#123;</span><br><span class="line">            <span class="built_in">merge</span>(no[i].u, no[i].v);</span><br><span class="line">            tr[no[i].u].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(no[i].u, no[i].v, no[i].cost));</span><br><span class="line">            res.<span class="built_in">push_back</span>(no[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>, res[p - s - <span class="number">1</span>].cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1139-最优布线问题"><a href="#1139-最优布线问题" class="headerlink" title="1139. 最优布线问题"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1141/">1139. 最优布线问题</a></h3><p>这个题比较符合稠密图的设定，所以说正好来用刚学的 Prim 算法试试手。<del>其实用Kruskal也能做</del></p>
<p>解法比较简单，单纯用 Prim 算法就行了，优先队列优化，在优先队列中存的是一条边上的边权和 to。</p>
<p><strong>AC code</strong></p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, gh[N][N], vis[N] = &#123;<span class="number">0</span>&#125;, s = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;pll, vector&lt;pll&gt;, greater&lt;pll&gt;&gt; q; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;gh[i][j]);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">pll</span>(<span class="number">0</span>, <span class="number">1</span>)); <span class="comment">//距离，to</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        pll now = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[now.second]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[now.second] = <span class="number">1</span>;</span><br><span class="line">        ans += now.first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">pll</span>(gh[now.second][i], i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


  </div>
  <div class="post-footer">
    
      <ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">算法学习笔记</a></li></ul>
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>
<footer>
  &copy; 2022
  <span class="author">
    red
  </span>
</footer>
    </div>
  </body>
</html>